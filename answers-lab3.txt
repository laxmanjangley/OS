1. What is the purpose of having an individual handler function for each exception/interrupt? (i.e., if all exceptions/interrupts were delivered to the same handler, what feature that exists in the current implementation could not be provided?)
Answer:
 Protection cannot be ensured when such a design is followed, also having a single handler for all functions would mean that the trap frame couldn't be kept identical, or the handler would have to be more complicated to determine whether or not to push a 0 for the error code.


2. Did you have to do anything to make the user/softint program behave correctly? The grade script expects it to produce a general protection fault (trap 13), but softint 's code says int $14 . Why should this produce interrupt vector 13? What happens if the kernel actually allows softint 's int $14 instruction to invoke the kernel's page fault handler (which is interrupt vector 14)?
Answer:
 The dpl for int 14 should be set to 0.  When the user tries to invoke it, it throws a protection fault (trap 13) in kernel mode. If the IDT was set up such that the interrupt for int 14 could be invoked then trap 14 could be used in page faults to allocate pages.

3. The break point test case will either generate a break point exception or a general protection fault depending on how you initialized the break point entry in the IDT (i.e., your call to SETGATE from trap_init ). Why? How do you need to set it up in order to get the breakpoint exception to work as specified above and what incorrect setup would cause it to trigger awgeneral protection fault?
Answer:
 This is because the permissions for T_BRKPT would determine whether user programs can use an int to throw a breakpoint trap. If the dpl for this is 0 then the case will give a general protection fault (int belongs to an inner ring), otherwise an int trap would be thrown.

4. What do you think is the point of these mechanisms, particularly in light of what the user/softint test program does?
Answer:
 Allowing certain interrupts to only be thrown by kernel mode adds some flexibility in trap handling.  For instance, if a page fault is only thrown in kernel mode, it can be used for lazy allocation of pages. When a user program throws a page fault for a page in memory we cannot abide by the lazy allocation because of the lower privilige level, the user/softint program does exactly this. Another issue with this is that when a user program has the freedom to throw any interrupt, it can throw a hardware interrupt or execute priviliged code which is bad for security reasons.