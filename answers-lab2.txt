Question 1:
Assuming that the following JOS kernel code is correct, what type should variable x have, uintptr_t or physaddr_t?
    mystery_t x;
    char* value = return_a_pointer();
    *value = 10;
    x = (mystery_t) value;
Answer: uintptr_t because an application can only deal with pointers in its virtual address space so x is a va.

Question 2:
What entries (rows) in the page directory have been filled in at this point? What addresses do they map and where do they point? In other words, fill out this table as much as possible:
	
	Entry	Base Virtual Address	Points to (logically):
	1023	?	Page table for top 4MB of phys memory
	1022	?	?
	.	?	?
	.	?	?
	.	?	?
	2	0x00800000	?
	1	0x00400000	?
	0	0x00000000	[see next question]
Answer:
	
	Entry	Base Virtual Address	Points to (logically):
	1023	0xffc0000		Page table for top 4MB of phys memory
	1022	0xff80000		Page table for second to top 4MB of phys mem
	.
	960		0xf0000000		Page table for bottom 4MB of phys memory
	959		0xefc00000		Current page table, kernel RW
	958		0xef800000		(0xefbfe000 - 0xefc00000 Kernel stack)
							(0xef800000 - 0xefbfe000 Invalid memory)
	957     0xef400000      Current page table kernel R-, user R-
	956		0xef000000		User page

Question 3:
We have placed the kernel and user environment in the same address space. Why will user programs not be able to read or write the kernel's memory? What specific mechanisms protect the kernel memory?
Answer: This is because PTE_U is not enabled in the kernel environment.

Question 4:
What is the maximum amount of physical memory that this operating system can support? Why?
Answer: The maximum size of UPAGES is 4MB, sizeof(struct PageInfo))=8Byte, so we can have at most 4MB/8B=512K pages, the size of one page is 4KB, so we can have at most 4MB/8B*4KB)=2GB physical memory.

Question 5:
What is the space overhead for managing memory, if we actually had the maximum amount of physical memory? How is this overhead broken down?
Answer:
We need 4MB PageInfo's (UPAGES) to manage memory, 2MB for page tables(each PT has 2^10 entries thus we get 2*2^30/4*2^10 pages (2^19 pages), this leads to 2^19/2^10 page tables and size per page table is 4*2^10 B which gives us 2MB of page tables (2^21 B)) and 4KB for the directory if we have 2GB memory. Total is 6MB + 4KB.

Question 6:
Revisit the page table setup in kern/entry.S and kern/entrypgdir.c. Immediately after we turn on paging, EIP is still a low number (a little over 1MB). At what point do we transition to running at an EIP above KERNBASE? What makes it possible for us to continue executing at a low EIP between when we enable paging and when we begin running at an EIP above KERNBASE? Why is this transition necessary?
Answer: After jmp *%eax finished. It is possible because entry_pgdir also maps va [0, 4M) to pa [0, 4M), it's necessary because later a kern_pgdir will be loaded and va [0, 4M) will be abandoned.